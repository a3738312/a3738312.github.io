{"./":{"url":"./","title":"Introduction","keywords":"","body":" 编程之道 "},"lan.html":{"url":"lan.html","title":"关于JS和TS","keywords":"","body":"关于JS和TS () => {} 方式定义的函数中 this 的指向固定为定义环境,funtion(){}方式定义的函数中 this 则是随着调用环境而变化，可以使用 funtion(){}.bind(object) 方式绑定 this 判断变量类型可以使用 typeof obj 会返回变量类型的字符串 es6中的Map可以使用 list = Array.from(map.values()); 来只将value放入数组。或者使用 list = [...map]; 来讲键值对都放入数组 for...in.. 可以用来遍历对象内部的属性及方法 for...of.. 专门用来遍历可迭代对象，比如数组，map，字符串等。如果数组中有部分下表没有赋值，则会跳过 可以使用以下方式在字符串中插入变量 `Name:${name}` or \"Name:\" + name Typescript可以这样重载方法 private toString(target: number): string; private toString(target: string): string; private toString(target: boolean): string; private toString(target: object): string; private toString(target): any { if (typeof target == \"number\") return \"number is \" + target; if (typeof target == \"string\") return \"string is \" + target; if (typeof target == \"boolean\") return \"boolean is \" + target; if (typeof target == \"object\") return \"object is \" + JSON.stringify(target); } ... let a: any[] = [1, \"ss\", 2, false, new Object()]; for (let obj of a) { cc.log(toString(obj)); } //output number is 1 //output string is ss //output number is 2 //output boolean is false //output object is {} 如果想打印 Typescript 中定义的枚举名，可以这样 enum Type { Type1 = 0, Type2 = 1 } console.log(Type[Type.Type1]);//output: Type1 console.log(Type[1]);//output: Type2 "},"cocoscreator.html":{"url":"cocoscreator.html","title":"Cocos Creator","keywords":"","body":"Cocos Creator 综合 替换服务器上资源一定要记得备份 遇事不决先保存 一个需求完成后，先提交一次再继续做别的需求 废弃代码及时清理 空闲的时候看以前写的代码是否可以优化 资源文件 ( 图片,预制体等 ) 名称不要有特殊符号和中文,可能会有问题 Cocos Creator 搭建安卓原生环境的时候要注意：Cocos Creator 安装目录和 sdk、ndk、ant 的路径都不能有中文和空格 Cocos Creator 编译安卓原生的时候有类似以下报错或找不到文件夹可能是因为项目路径太深 fatal error: opening dependency file ... No such file or directory CocosCreator 中 Java 和 JS 互相调用 如何在 Android 平台上使用 JavaScript 直接调用 Java 方法 (特别注意 String 的方法签名 Ljava/lang/String; 后面的分号一定要加上去) 在 TS 中引用 JS import js = require(\"./js\") 在 JS 中引用 TS import ts from \"./ts\"; 在资源管理器里删除资源或者手动移动资源后如果有报错，把 library local temp 目录删掉重新打开 TS 循环引用会报错 Git 同步场景可能会因为冲突导致无法解决的报错，这时可以放弃较少修改的部分，同步完后重新修改场景再提交 node._touchListener.setSwallowTouches(false); 可以让去掉点击事件截断，非父子节点也可穿透，需要在注册点击事件之后调用才会有效；使用 cc.macro.ENABLE_MULTI_TOUCH = false; 关闭多点触碰，会导致点击事件被其他节点截断，哪怕层级本该被该层级遮挡；若父节点们有一个添加了 BlockInputEvents 组件或 swallowTouches 的值为 true 的节点或按钮，则穿透会失效 Cocos Creator 默认的摄像机是透视模式的，如果需要用 3D 节点做倾斜文字，需要将摄像机设置为正交摄像机，不然因为透视会导致每个 3D 节点显示的角度不一样。 CCLabel 的 string 修改后节点大小会在下一帧才刷新，2.2 版本前可以使用 label._updateRenderData() 来手动刷新节点大小，之后可以使用 label._forceUpdateRenderData() 来刷新。刷新后获取节点大小就是修改内容后正确的大小 cc.audioEngine.setFinishCallback(id, null);//设置完成回调函数不能写 null，会导致原生平台报错 Spine 骨骼动画可以在不同轨道播放动画来实现动画混合效果，轨道动画播放完之后需要清除轨道动画，否则动画会一直覆盖在上面。使用 setTrackCompleteListener 来监听动画是否播放完毕 在项目中设置好布局之后，在项目的 项目目录/local/layout.editor.json 找到 layout 字段，将字段内容复制到 编辑器目录/resources/static/layout 中找到 landscape.json 并拷贝进去，即可替换 在 2.4.3 中发现，Collider 碰撞组件修改 size 或者 offset 之后调用 apply() 应用修改时，会让碰撞组件启用，效果等同于 enabled 设置为 true；但实际上 enabled 的值并不会发生变化，所以如果碰撞组件在关闭的情况下修改大小位置等并应用，且在之后马上设置 enabled 为 false 会出现没有效果的问题，在 enabled 为 false 的情况下修改碰撞组件参数，不需要调用 apply()，在下次 enabled 值设置为 true 会应用 对于刚体碰撞反馈的缩放，最好采取显示节点缩放，而不是对有刚体的节点直接缩放。因为直接对刚体节点缩放时，会重新构建这个刚体依赖的全部碰撞体 2.x 中，通过修改 ...\\resources\\static\\template\\new-script.ts 可以自定义创建脚本模板 可以通过在所有 UI 顶部叠加一层白色Sprite来增加整个界面的亮度，将Sprite的混合模式设置为 Src Blend Factor SRC_ALPHA Dst Blend Factor ONE 可以通过改为以下设置实现颜色加深 Src Blend Factor SRC_ALPHA Dst Blend Factor DST_COLOR 骨骼动画导出二进制可以减少骨骼动画的大小，spine 骨骼动画导出时后缀需要改为 .skel 若在安卓端遇到 T &spine::Vector::operator[](size_t) 类似的报错，有可能是导出问题，取消勾选 警告、动画清除、非必要的数据 重新导出即可 透明边图片出现黑边可以这样去除黑边 勾选纹理的透明预乘 修改 Sprite 的 Blend Factor 为 ONE IOS 上 event.getID() 获取当前触点 ID 和其他平台不一样，使用 event.getTouches() 获取触点列表来判断触点数量 Spine骨骼动画使用 setAnimation 来播放动画时可以通过返回的 trackEntry 对象来设置该轨道上的动画状态，如timeScale等 有损压缩Spine使用的材质可能会导致渲染出现色块，可以通过取消勾选Premultiplied Alpha或使用无损压缩来解决 Shader OpenGL ESLearn OpenGL CN 大致流程 获取图像数据流 顶点处理 根据投影等矩阵变换改变顶点位置，并根据顶点位置来计算纹理坐标的位置 图元拼装 根据处理好的顶点及纹理坐标信息，将纹理组装成图元 栅格化操作 根据处理好的图元数据，分解成更小的对应缓冲区像素的片元 片元处理 通过纹理坐标取得纹理中相对应的片元像素值,根据自己的业务处理来变换这个片元的颜色 帧缓冲操作 将最终的像素值写入帧缓冲区 顶点着色器 是用来替代 顶点处理 阶段的，片元着色器 是用来替代 片元处理 阶段的 Cocos creator Effect 语法使用 GLES语法(与C语言很相似)，所以语法学习并不难，难点在于数学 关于插件 JS 文件可以勾选导入为插件，插件 JS 文件不可用 ccclass 类，会在游戏代码前加载，可以用于初始化一些全局变量、方法等 关于 Tiled Map 可以在 Tiled Map 中新建对象层，使用多边形来设置不规则碰撞箱，在 Cocos Creator 内获得所有多边形的数组来动态生成多边形碰撞： let objects = map.getObjectGroup(\"collision\").getObjects(); //获取对象层内所有对象 for (let i = 0; i 关于游戏优化 加载场景时会把场景依赖的资源也一起加载，所以尽量不要把所有东西都放在场景内 关于内存占用，动态加载预制体也会把预制体依赖的资源一起加载进来，所以要及时释放掉 图片纹理占用内存是根据色彩存储方式计算的，一般保存文件都是 ARGB8888 每个像素占四位，即 A=8，R=8，G=8，B=8，那么一个像素点占 8+8+8+8=32 位 所以一张 1024 x 1024 的图片，占用内存就是 1024 x 1024 x 32 = 33554432 位，也就是 8.192MB，但是如果换成 ARGB4444 每个像素占四位，即 A=4，R=4，G=4，B=4，那么一个像素点占 4+4+4+4=16 位 同样 1024 x 1024 的图片，占用内存就是 1024 x 1024 x 16 = 16777216 位，也就是 4.096MB，但是相对的，也会有一定的失真 开启动态合图的情况下，将可以参与动态合图的节点相邻即可合并 Draw call，Label 默认会打断合批，但是如果文本缓存模式设置为 Bitmap 或 Char 则也可以参与动态合图，从而降低 Draw call 当需要向下取整时，可以将 Math.floor(1.22) 换成 ~~1.22 性能会有所提升，将字符串转换为整型数字时，也可以使用 ~~\"133\" 性能会有所提升。 游戏性能调优Cocos Creator 性能优化：DrawCall（全面！）Cocos Creator 微信小游戏平台启动与包体优化（首屏渲染耗时降低 50%）自定义渲染合批之自定义顶点格式（附 Demo 和引擎源码解读）解读 Cocos Creator 引擎：让实例化快 50% 的原理，“拖节点”性能会更好吗？如何提升 JSON.stringify()的性能？ 挺不错的文章 还未整理分类 Cocos 入门指引使用 Creator 三年的游戏开发总结[教程] | 物理挖洞/涂抹地形的几种实现讨论 [大集合整理篇][教程]Creator 迷宫的生成: DFS 与 BFS 算法实现[ituuz 分享]探照灯效果 shader 实现Cocos3D《病毒传播模拟器》游戏版本 1 开发日志和总结slg 系列（地图篇）3d 透视无限地图完成……其他补充中..slg 细分篇 ——— 无限地图原理自定义渲染合批之自定义顶点格式（附 Demo 和引擎源码解读）Cocos Creator 一种「无侵入」资源加密方案Cocos Creator 通用框架设计 —— 资源管理Cocos Creator 通用框架设计 —— 资源管理优化Cocos Creator 水的浮力实现过程制作一个可以将小游戏快速接入 APP 的安卓 SDK-开篇解读 Cocos Creator 引擎：cc.AssetManager（1）重构后的 cc.loader如何巧用设计图提高 UI 的还原度使用 CocosCreator 模拟书本翻页效果Creator web 平台 setting.js 文件详细解析和资源加载解析cocos 实现对 ETC2 的支持避免纹理抖动使用 2 种方式实现动画的动态蒙版 "},"ccclass.html":{"url":"ccclass.html","title":"CCClass 中属性 property 属性参数","keywords":"","body":"CCClass 中属性 property 属性参数 type 限定属性的数据类型 @property({ type: cc.Node }) test: cc.Node = null; //or @property(cc.Node) test: cc.Node = null; //数组 @property({ type: cc.Node }) private test: cc.Node[] = []; //or @property([cc.Node]) private test: cc.Node[] = []; //如果将 type 设置为枚举，则在属性编辑器中会显示一个下拉框 //枚举的值不支持字符串 enum TestEnum { Value1 = 0, Value2 = 1 } ... @property({ type: cc.Enum(TestEnum) }) private test: TestEnum = TestEnum.Value1; //可以通过使用 cc.Component.EventHandler 类型，添加一个和Button一样的事件回调 @property(cc.Component.EventHandler) private callback: cc.Component.EventHandler = null; visible 在 属性性检查器 中显示或隐藏 isShow: boolean = false; @property({ type: cc.Node, visible() { return this.isShow; } }) test: cc.Node = null; displayName 在 属性检查器 中显示为另一个名字 @property({ type: cc.Node, displayName: \"节点\" }) test: cc.Node = null; tooltip 在 属性检查器 中添加属性的 Tooltip，将鼠标悬浮于属性上会出现对应的字符串 @property({ type: cc.Node, tooltip: \"这是一个节点\" }) test: cc.Node = null; multiline 在 属性检查器 中使用多行文本框 @property({ multiline: true }) private string: string = \"\"; readonly 在 属性检查器 中只读 @property({ readonly: true }) private string: string = \"over\"; min 限定数值在编辑器中输入的最小值 @property({ min: 0 }) private index: number = 0; max 限定数值在编辑器中输入的最大值 @property({ max: 1 }) private index: number = 0; step 指定数值在编辑器中调节的步长 @property({ step: 1 }) private index: number = 0; range 一次性设置 min, max, step @property({ range: [0, 1, 1] }) private index: number = 0; slide 在 属性检查器 中显示为滑动条，需要设置 max 及 min， step 无效 @property({ slide: true, min: 0, max: 10, step: 1 }) private index: number = 0; serializable 序列化该属性，指定了 default 默认值的属性默认情况下都会被序列化，序列化后就会将编辑器中设置好的值保存到场景等资源文件中，并且在加载场景时自动还原之前设置好的值 @property({ serializable: true }) private index: number = 0; formerlySerializedAs 指定之前序列化所用的字段名，重命名属性时，声明这个参数来兼容之前序列化的数据 editorOnly 在导出项目前剔除该属性 default 定义属性的默认值 //ts @property({type: cc.Node}) private test: cc.Node = null; //js test: { default: null, type: cc.Node } notify 当属性被赋值时触发指定方法，用法同 visible 需要定义 default 属性并且不能用于数组，也不支持 ES6 定义方式 override 当重写父类属性时需要定义该参数为 true animatable 该属性是否能被 动画编辑器 修改，设置为 true 后该属性可以在动画编辑器中添加动画 定义 get/set 方法，设置 get 后，属性无法被序列化，也无法设置默认值 //ts private _color: cc.Color = cc.Color.WHITE; @property({ type: cc.Color }) get color() { return this._color; } set color(color: cc.Color) { this._color = color; } //js color: { default: cc.Color.WHITE, type: cc.Color get: function () { return this._color; }, set: function (value) { this._color = value; } }, "},"editor.html":{"url":"editor.html","title":"Editor 参数","keywords":"","body":"Editor 参数 executeInEditMode允许当前组件在编辑器模式下运行。默认情况下，所有组件都只会在运行时执行，也就是说它们的生命周期回调在编辑器模式下并不会触发。值类型：Boolean默认值：falseJS: cc.Class({ extends: cc.Component, editor: { executeInEditMode: true } }); TS: const { executeInEditMode } = cc._decorator; @executeInEditMode export default class Class extends cc.Component { ...... } requireComponentrequireComponent 参数用来指定当前组件的依赖组件。当组件添加到节点上时，如果依赖的组件不存在，引擎将会自动将依赖组件添加到同一个节点，防止脚本出错。该选项在运行时同样有效。值类型：Function （必须是继承自 cc.Component 的构造函数，如 cc.Sprite）默认值：nullJS: cc.Class({ extends: cc.Component, editor: { requireComponent: cc.Sprite } }); TS: const { requireComponent } = cc._decorator; @requireComponent(cc.Sprite) export default class Class extends cc.Component { ...... } executionOrder脚本生命周期回调的执行优先级。小于 0 的脚本将优先执行，大于 0 的脚本将最后执行。该优先级只对 onLoad, onEnable, start, update 和 lateUpdate 有效，对 onDisable 和 onDestroy 无效。值类型：Number默认值：0JS: cc.Class({ extends: cc.Component, editor: { executionOrder: -1 } }); TS: const { executionOrder } = cc._decorator; @executionOrder(-1) export default class Class extends cc.Component { ...... } disallowMultiple当本组件添加到节点上后，禁止同类型（含子类）的组件再添加到同一个节点，防止逻辑发生冲突。值类型：Boolean默认值：falseJS: cc.Class({ extends: cc.Component, editor: { disallowMultiple: true } }); TS: const { disallowMultiple } = cc._decorator; @disallowMultiple export default class Class extends cc.Component { ...... } menumenu 用来将当前组件添加到组件菜单中，方便用户查找。值类型：String （如 \"Rendering/Camera\"）默认值：\"\"JS: cc.Class({ extends: cc.Component, editor: { menu: \"Menu/Class\" } }); TS: const { menu } = cc._decorator; @menu(\"Menu/Class\") export default class Class extends cc.Component { ...... } playOnFocus当设置了 executeInEditMode 以后， playOnFocus 可以用来设定选中当前组件所在的节点时，编辑器的场景刷新频率。playOnFocus 如果设置为 true，场景渲染将保持 60 FPS，如果为 false，场景就只会在必要的时候进行重绘。值类型：Boolean默认值：falseJS: cc.Class({ extends: cc.Component, editor: { playOnFocus: true } }); TS: const { playOnFocus } = cc._decorator; @playOnFocus export default class Class extends cc.Component { ...... } inspector自定义当前组件在 属性检查器 中渲染时所用的网页 url值类型：String默认值：\"\"JS: cc.Class({ extends: cc.Component, editor: { inspector: \"packages://inspector/inspectors/comps/button.js\" } }); TS: const { inspector } = cc._decorator; @inspector(\"packages://inspector/inspectors/comps/button.js\") export default class Class extends cc.Component { ...... } help指定当前组件的帮助文档的 url，设置过后，在 属性检查器 中就会出现一个帮助图标，用户点击将打开指定的网页。值类型：String默认值：\"\"JS: cc.Class({ extends: cc.Component, editor: { help: \"https://example.com/help.html\" } }); TS: const { help } = cc._decorator; @help(\"https://example.com/help.html\") export default class Class extends cc.Component { ...... } "},"assetsbundle.html":{"url":"assetsbundle.html","title":"AssetBundle","keywords":"","body":"AsseBundle 2.4.x 版本的 AssetBundle 为了兼容旧版本，也保留有 cc.resources，但 resources 也是一个内置 Bundle，会在引擎加载时加载 2.4.x 版本的 cc.assetManager.loadBundle 只会加载 Bundle 的配置文件(config.json)及该 Bundle 中的所有脚本(index.js)，加载完毕会返回一个 Bundle 对象，可以通过这个对象来加载 Bundle 内的资源://cc.Asset 为指定类型，如果加载文件夹，将会只返回指定类型的资源 //loadDir 会加载文件夹下所有资源，包括子文件夹 bundle.loadDir(assetUrl, cc.Asset, (finish: number, total: number) => { }, (error: Error, asset: cc.Asset) => { }); bundle.load(assetUrl, cc.Asset, (finish: number, total: number) => { }, (error: Error, asset: cc.Asset) => { }); 2.4.x 版本的 cc.assetManager.loadRemote 远程下载单个文件可以通过在 options 中添加 {onFileProgress:(loaded, total) => {} } 来获取下载进度。 cc.assetManager.loadRemote(url, { onFileProgress: (loaded: number, total: number) => { console.log(loaded / total);//获取进度 } }, (error: Error, asset: cc.Asset) => { }); 但是因为下载远程文件用的 XMLHttpRequest 所以必须在服务器端做好相关配置。如果没有办法添加则可以继续使用 cc.loader.load 来加载远程资源，截至2.4.3该API还没有移除。 cc.assetManager.loadBundle 可以加载本地 Bundle ，开发时可以直接构建然后加载 AssetBundle 包进行测试 cc.assetManager.loadBundle(\"D:/build/Bundle\", null, (err: Error, bundle: cc.AssetManager.Bundle) => { }); AssetBundle 可以包含代码，但是使用时不可以直接引用 Bundle 包里面的类， Bundle 包里的脚本也不可以直接引用外部脚本，否则会导致脚本被打包到主包，使用时需要使用 node.getComponent('className'); 的方式来获取脚本实例 AssetBundle 的版本号就是打包出来之后中间的这段字符串 config.版本号.json index.版本号.js 若勾选md5，则会自动添加md5字符串，也可以手动填写，如 index.1.0.js 加载时版本号填写 {ver: '1.0'} 即可 可以通过以下代码获取bundle中所有资源路径，且不需要加载资源 //_config为私有属性，不推荐使用，但当前官方并未提供获取api let map = bundle._config.paths._map; let tmpArr = []; for (var item in map) { tmpArr.push(item); } console.log(tmpArr);//[\"path1\",\"path2\",\"path3/path\"]; 通过 bundle 对象加载的资源，需要自己管理释放；资源加载后默认引用计数为0，使用 asset.addRef() 可以增加资源引用，使用 asset.decRef() 可以减少资源引用，当引用计数减少到0时，会自动尝试释放资源 AssetBundle 使用 loadDir 加载文件夹时，如果文件夹下有子文件夹，会导致进度回调中的 total 字段随着加载增加，会出现 finish / total 获取的进度不准确 cc.assetManager.bundles 可以查看当前已加载的所有 bundle AssetBundle 加载的代码资源无法清除缓存，加载的 Bundle 内若有与现有脚本同名的脚本则会报错 AssetBundle 打包的时候需要设置目标平台为对应平台，否则可能出现资源加载问题 "},"android.html":{"url":"android.html","title":"安卓原生","keywords":"","body":"安卓原生 通过使用PowerManager里面的WakeLock可以使游戏不息屏 Android-WakeLock(唤醒锁与CPU休眠/屏幕常亮) 接入一些需要设置某些值的SDK，要判断SDK和游戏都初始化完毕了再做后面的事情 Google play servers 接入的时候要注意创建OAth2.0客户端，一个调试客户端，一个正式客户端 安卓Facebook分享需要base64图片或bitmap，可以在JS里处理图片(截图、拼图等)然后调用 typescriptb.saveImageData() 保存在本地，安卓根据路径读取图片直接以bitmap传入即可(会比较块) Cocos Creator 生成的配置文件里，主Acticity的任务关联是空字符串，会导致其他的Actictiy独立于App显示在最近任务中，比如激励视频广告 android:taskAffinity: 与 Activity 有着相似性的任务。从概念上讲，具有同一相似性的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。任务的相似性由其根 Activity 的相似性确定。（可以用来制作小程序这样独立于app的任务） 相似性确定两点内容 — Activity 更改父项后的任务（请参阅 allowTaskReparenting 属性），以及通过 FLAG_ACTIVITY_NEW_TASK 标记启动 Activity 时，用于容纳该 Activity 的任务。 默认情况下，应用中的所有 Activity 都具有同一相似性。您可以设置该属性，以不同方式将其分组，甚至可以在同一任务内放置不同应用中定义的Activity。如要指定 Activity 与任何任务均无相似性，请将其设置为空字符串。(若主Activity设置为空字符串则所有任务都没有相似性) 如果未设置该属性，则 Activity 会继承为应用设置的相似性（请参阅元素的 taskAffinity 属性）。应用默认相似性的名称为元素所设置的软件包名称。 安卓查询最近系统发的广播：adb shell dumpsys | grep BroadcastRecord 谷歌的广告归因需要将firebase接入到项目中 谷歌支付如果查询不到商品信息，可能是应用没有上架谷歌商店 谷歌支付如果闪一下返回错误6，有可能是谷歌商店没有允许后台运行和后台开启 或许会用到的东西： 使用外部存储： 关于获得安卓外部存储读写权限 Android 文件外/内部存储的获取各种存储目录路径 接入Facebook Banner广告可以新建一个Activity然后把AdView添加到该Activity上 谷歌广告归因测试： adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n \"包名/Receiver完整地址\" --es \"referrer\" \"utm_source%3DtestSource%26utm_medium%3DtestMedium%26utm_term%3DtestTerm%26utm_content%3DtestContent%26utm_campaign%3DtestCampaign\" 安卓JAVA和webview内部js交互 //给webview注册监听接收js调用 webView.addJavascriptInterface(new gameViewAPI(), \"gameViewAPI\"); //接受js调用的方法 static class gameViewAPI { @JavascriptInterface public String sendMsgToJava(final String __msg) { //处理数据 return \"\"; } } public static void sendMsgToGame(final String __msg) { if (webView != null && activity != null) { //发送消息到游戏必须在ui线程调用 activity.runOnUiThread(new Runnable() { @Override public void run() { //发送消息到游戏 //window.revMsgFromLobby在js中全局定义 webView.loadUrl( \"javascript:window.revMsgToJava(\" + __msg + \")\"); } }); } else { Log.d(TAG, \"webview or activity is null\"); } } // js调用java if (window.gameViewAPI && window.gameViewAPI.sendMsgToJava) { LogComponent.Log(\"sendMsgToJava: \" + __msg); window.gameViewAPI.sendMsgToJava(__msg); } //接收java调用,要在全局的地方定义 window[\"revMsgToJava\"] = (data: string) => { //处理数据 } or window.revMsgToJava = (data) => { } 安卓获取设备ID 写effect的时候要注意参数格式不能有boolean，因为安卓底层转换格式没有boolean 使用 Android studio 打开构建出的安卓项目时，若出现一下报错，可能是 NDK 路径配置或 NDK 版本有问题A problem occurred configuring project ':app'. java.lang.NullPointerException (no error message) 亚马逊与谷歌同时使用AdMob广告需要使用不同的包名 此方式引入会导致引入所有的 firebase 相关包 播放音频后同一帧或极短时间内调用stop停止音频，可能会引发系统死锁进而导致闪退。报错日志可能包含此关键词 pthread_mutex_lock "},"instancegame.html":{"url":"instancegame.html","title":"小游戏","keywords":"","body":"小游戏 QQ小游戏 远程加载资源有不支持的文件格式，下载不支持的格式会报错 Download Fielded CocosCreator 在 QQ 小游戏里获取环境是安卓，要加判断 CocosCreator 发布 QQ 小游戏流程：发布微信小游戏，用VS Code打开微信小游戏文件夹，全局搜索 wx. 替换成 qq.。saveFile 前需改成fs ( 和微信不一样 ) qq小程序开发者工具打开工程会报错时更新到最新版即可 字节跳动小游戏 CocosCreator 2.4.2 之前的版本直接发布微信小游戏，之后可以直接发布字节跳动小游戏 OPPO小游戏 远程音频下载后用本地地址或者直接使用远程地址的音效不能用 Cocos Creator 自己的音频引擎播放，需要使用 OPPO 的 InnerAudioContext 来播放 //官方示例 var audio = qg.createInnerAudioContext(); audio.loop = true; audio.volume = 0.7; audio.autoplay = false; var playSound = function() { audio.play(); audio.offCanplay(playSound); } audio.onCanplay(playSound); audio.src = 'res/demo.mp3'; 音频播放在切后台的时候调用暂停音频的话，在切前台的时候有可能音频还会自动播放，但是音频当前状态还是暂停，这种时候可以在且前台先调用 audio.play() 再调用 audio.pause() 来暂停 VIVO小游戏 VIVO小游戏的远程音频需同OPPO一样处理 VIVO小游戏在游戏里播放 cc.AudioClip 会出现没有声音的问题，需要修改源码： //调整下 [creator目录]/resource/builtin/vivo-adapter/engien/jsb-audio.js 的接口 //cc.audioEngine.playEffect 为 cc.audioEngine.playEffect = function (filePath, loop) { return cc.audioEngine.play(filePath, loop || false, _effect.volume); }; 2.4.x版本中使用 cc.assetManager.loadBundle 加载bundle获取加载进度时会添加 onFileProgress 参数，vivo返回的加载进度为一个对象，类型为 { progress: string, totalBytesWritten: number, totalBytesExpectedToWrite: number } cc.assetManager.loadBundle( \"Bundle\", { onFileProgress: (data: { progress: string; totalBytesWritten: number; totalBytesExpectedToWrite: number; }) => { console.log(\"Bundle load:\" + JSON.stringify(data)); }, }, (error: Error, bundle: cc.AssetManager.Bundle) => {} ); 小程序SDK接入 部分版本main.js如果开了md5的话不能设置模板，所以有引用js的话每次出包都要记得加上 "},"wechat.html":{"url":"wechat.html","title":"微信小游戏的优化","keywords":"","body":"微信小游戏的优化 来自网友的pdf，不知道作者是谁 一、内存优化 因为 iOS 小游戏和微信共用同一个进程，而微信在连续两次收到系统内存警告的时候会关闭小游戏并释放小游戏占用的内存。 如果你的小游戏有外网用户反馈“闪退”，或者你自己测试的时候频繁出现“该小程序可能导致微信响应变慢被终止”等提示，那么就应该是时候优化你的小游戏内存了！ 1. 优化双份纹理（必做！） 在你的项目中添加如下代码，就可以减少大量内存： cc.game.once(cc.game.EVENT_RENDERER_INITED, () => { let oldHandleLoadedTexture = cc.Texture2D.prototype.handleLoadedTexture; let optimizedHandleTexture = function (premultiplied) { oldHandleLoadedTexture.call(this, premultiplied); this._image.src = ''; //for cocos creator 1.4 //this._htmlElementObj.src = ''; } cc.Texture2D.prototype.handleLoadedTexture = optimizedHandleTexture; }); 这里面的原理是，当 Creator 使用 DOM 的 Image 对象去加载一个图片资源的时候，微信底层的引擎会解码图片数据，同时往 GPU 上传一份纹理，然后引擎的 Sprite 在渲染的时候会使用这个 DOM Image 再生成一份 GPU 纹理并上传，导致 GPU 里面存在双份纹理。使用 Image.scr = '' 可以释放掉 GPU 里面多出来的一份纹理，同时也会释放 CPU 端解码的纹理内存。所以，基本上对 Image 对象调用了 src = '' 这个操作，这个 Image 对象占用的内存就释放干净了。 之前尝试使用 DOM Image pool ，当一个图片资源解码成功并且上传 GPU 以后，把这个 Image 对象的 src 置空后放入池子，然后重复利用。不过对比了一下内存占用，感觉 src = '' 之后内存立即就释放了，优化作用并不是很明显。 2. 优化图集 最好对所有的碎图资源进行图集合并（ Creator 自带一个自动图集合并工具），并且最大限度填满图集，不要留有太多空白。图集的大小尽可能限制在 1024*1024 以下，因为有些图片有不少透明像素，合并图集的时候可以 trim 掉这些透明像素。另外合图还可以优化 Drawcall ，减少图片读取和解码操作，对性能也有一定优化。 另外，对于显示效果要求不高的界面，可以适当降低图片的尺寸。 3. 优化 Label Creator1.9.3 之前的版本，每创建一个系统字体就会生成一个离屏的 Canvas 对象，然后保存这个 Canvas 对象的 context ，每次 draw 一个系统字体的时候会调用这个 context 的 fillText方法生成一张纹理并渲染。 1.9.3 以后我提交了一个优化，所有的系统字体渲染共享一个离屏 Canvas ，这样大概可以优化 30M 左右的内存（不同的项目效果不一样）。 老引擎参考 PR 地址：optimization label memory #2693 fix label rendering issue #2880 (这个 PR 主要是 Bug 修复) 4. 优化资源释放 对于二级弹框和场景资源释放，可以使用 cc.loader.release 接口配合场景的“自动释放”属性来实现。 对于一个二级面板，我们可以约定这个二级面板引用的资源范围。我们把游戏中共用的资源放到 Common 图集中，把每个二级面板的资源放到自己的图集中。当释放资源的时候，我们可以通过 cc.loader.getDependsRecursively( 'prefab url' ) API 拿到面板 Prefab 所引用的所有资源，然后对这个返回的资源数组做资源释放。 比如，在我们的项目里面，释放资源的时候，我排除了 Common ， Main ， Game/FX 目录下面的图集资源： releaseAllDeps(deps) { deps.forEach((item) => { if (item.indexOf('UITexture/Common') === -1 && item.indexOf('UITexture/Main') === -1 && item.indexOf('UITexture/Game/FX') === -1) { cc.loader.release(item); } }); } 场景的资源释放只需要勾选一个属性就可以了： 二、性能优化 目前小游戏的性能瓶颈大多在 JS 层面，可以使用 Chrome 先去 profiles 性能热点，然后针对性地去做优化。 这里给出几点优化建议 1. 游戏中频繁更新的文字，推荐使用 BMFont ，系统字体会比较消耗性能。 2. 优化 Drawcall ，尽可能减少 Drawcall 数量。 3. 减少 Mask 组件的使用，该组件会导致游戏中的 Drawcall 数量变多。 4. 禁用引擎的 culling ，禁用方法 cc.macro.ENABLE_CULLING = false 。 5. 如果使用物理引擎，可以把物理引擎的 step 间隔调大。 6. 优化节点树，减少节点数量。 7. 场景中不要挂载过多的 Prefab ，可适当将一些 Prefab 变成动态加载的。 三、包体优化 因为微信小游戏对于包体有 4M 的限制，最近才刚开始升到 8M ，但是必须要分包，而且每一个分包的大小还是不能超过 4M 。 下面给出一些优化建议： 1. 首包中不要包含过多的资源，如果一定要包含，请务必压缩。对于背景图片可以使用 JPG ， PNG 图片可以使用 png8 进行压缩。 2. 代码必须使用 uglify 进行压缩，尤其是第三方库，游戏代码如果使用 release 构建引擎有 做 uglify 。如果想进一步压缩代码体积，需要考虑使用 Google Closure Compiler 进行高级压缩。 3. 不需要动态加载的图片资源不要放到 resources 目录，放到此目录的资源在构建导出的时候，会生成资源映射关系到 Settings.js 中，会导致该 Settings.js 文件变大。另外为了防止缓存问题，需要使用 md5 ，此时 Settings.js 文件会进一步膨胀。过气的活动 Prefab 也可以移出 resources 目录，所以定期资源清理也是必要的。 4. Settings.js 文件优化，可以自己写脚本把 md5Map 里面的 rawAssets 的 md5 映射存到原本的 rawAssets 中，然后在 boot.js 里面还原 md5Map 即可。优化之后的 Settings.js 长这个样子： boot.js 里面还原 md5AssetMap 的的代码： rawAssets = _CCSettings.rawAssets; assetTypes = _CCSettings.assetTypes; md5AssetsMap = _CCSettings.md5AssetsMap; for (let mount in rawAssets) { let entries = rawAssets[mount]; for (let uuid in entries) { let entry = entries[uuid]; let type = entry[1]; if (typeof type === 'number') { entry[1] = assetTypes[type]; } if (entry[2] && (typeof entry[2] === 'string')) { md5AssetsMap['assets/' + entry[0]] = entry[2]; } } } 5. 一定要使用 release 模式构建，这种方式构建出来的 json 资源会压缩， Settings.js 也会优化。 6. 对于引擎不使用的模块进行裁剪，这个可以减少引擎大小 "},"github.html":{"url":"github.html","title":"GitHub相关","keywords":"","body":"关于GitHub GitHub为何物 GitHub 是一个开源的托管服务，有点像代码的云。它以各种不同的编程语言托管您的源代码项目，并跟踪每次迭代所做的各种更改。该服务可以通过使用 git(一种在命令行界面中运行的修订控制系统) 来完成此操作 —— GitHub是什么 如何使用GitHub github怎么使用 访问GitHub慢怎么办 修改DNS设置，将首选DNS改为 1.1.1.1 备用DNS改为 1.1.0.0 即可 Github配置 git config --global user.name 可以设置全局 git 用户名，该信息会在提交时附带 git config --global user.email 可以设置全局 git 邮箱，该信息会在提交时附带 可以通过先在 Github web修改一些东西提交，本地查看提交记录来得到 Github 上配置的用户名和邮箱，来防止网页提交和本地提交变为两个用户 在 Github 的 Setting -> Email 中找到 [x] Keep my email addresses private 改为 [ ] Keep my email addresses private 即可直接关闭邮箱加密，直接使用设置中的邮箱显示 git config --global http.proxy http://... 可以设置http代理 git config --global https.proxy https://... 可以设置https代理 关于GitBook GitBook为何物 GitBook 是一款工具，它可以让你把用 markdown 写的文档转换成 html 或 pdf 格式，方便阅读GitBook 主要由两个组件组成 一个名为 GitBook 的命令行工具 gitbook.com,一个 GitBook 专用的托管服务 如何使用GitBook Gitbook官方文档(英文)GitBook的安装和使用使用GitBook发布文章 "},"harmony.html":{"url":"harmony.html","title":"鸿蒙开发相关","keywords":"","body":"鸿蒙开发相关 CocosCreator发布流程参考 配置应用签名信息 CocosCreator发布鸿蒙可能遇到的问题 不要使用最新版的NDK "}}